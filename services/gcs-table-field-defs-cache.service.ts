import { Injectable } from '@angular/core';
import { Observable, map, shareReplay } from 'rxjs';

import { GcsDataService } from 'services/gcs-data.service';

/*
columnSchema is used to render the fields in the dialog, defining the properties, behavior and validation.
Each line represents a field like "fieldname moodletype //colhdr|... "

Its properties are parsed from the line string into columnSchema (in parseMoodleRecStr) as follows:
key = fieldname
type = moodletype

Then, following the // is a "|" separated list of designators, either one-word keywords, key=val pairs or operation() set.  The supported designators are:
(the colhdr is always the first one and has no designator, it is just the text to display in the column header)

Field type keywords:
bool (converts int to bool)
date (converts int to date)
text (converts string to text)

List Control keywords:
nolist (applies only to the record list)
nosort (apply only to the record list)

Dialog Control designators:
newline (moves field to a new line)
width= (display width of field in pixels) e.g. width=120px
show= (how control is shown, one of show, readonly, hide) e.g. show=hide
val() (CSV validation designators, one of required) e.g. val(required)
sel() (specifies a table to use to populate a select list) e.g. sel(tbl,program) or sel(codeset,term)
popup() (popup link identifier) e.g. popup(enrollagreement)

Now, bear in mind that a dialog can be for update or add and you may not want these to operate in the same way.  To accomplish this, specify the designators that are
unique to each mode in the respective add and upd designator like upd(xxx,xxx,xxx,...) or add(xxx,xxx,xxx,...).  Any designators specified outside of the add and upd
designators in the "|" list will apply to both modes.

The supported mode designators (these are dynamically parsed by flddefsForDialogMode when dialog is opened) are:
newline
show=
popup()

width=, val() and sel() will always apply to both modes.

For illustration:
agreementid int   //Enr Agr ID|nolist|newline|upd(show=readonly)|add(show=hide)|popup(enrollagreement)|width=130px

The above line is parsed into columnSchema as follows:
key: agreementid
type: int
colhdr: Enr Agr ID
islist: false
isnewline: true
add: show=hide,popup(enrollagreement)
upd: show=readonly,popup(enrollagreement)
widthval: 130
*/
export class columnSchema {
  public isnative: boolean = false;// Indicates the field is from the native table.  For example, the buttons column is added by the app and is not a native field.

  // properties common to all modes
  public key: string = '';// table record field name
  public dbtype: string = '';// db data type: int, string
  public type: string = '';// how to display: int, bool, date, text, select, popup, buttons
  public colhdr: string = '';// column header text
  public widthval: string = '120';// optional but for now, always treated as px
  public ishtml: boolean = false;// possible html tags embedded and needs to be escaped for moodle (optional, default false)
  public tooltip: string = '';// optional tooltip text

  // list-specific control properties
  public islist: boolean = true;// show in list (optional, default true)
  public issort: boolean = true;// sortable (optional, default true)

  // mode properties specific to the mode.  These are transferred from the original string definitions and the compile deferred until the dialog is opened.
  public add: string = '';// csv list of designators used for add mode (optional, default '').
  public upd: string = '';// csv list of designators used for upd mode (optional, default '').

  // derived properties generated by parseMoodleRecStr and common to all modes
  public sellist: string = '';// sel list for code lookups in table list (optional, default '')
  public isrequired: boolean = false;// true requires a value (optional, default true)

  /*
 "working" set of properties initialized when the dialog is opened and solely for its transitive use.  these are derived from either
 the add/upd property based on whether adding or updating the record. Breaking out these directives simplifes the template logic and
 just requires a quick compile each time the dialog is opened to isolate the properties that are relevant to the mode.
 */
  public show: string = '';// how field is displayed: show, hide, readonly
  public isnewline: boolean = false;// start on new line?
  public popupid: string = '';// popup identifier defined in standard-dialog-add-upd-table.html (e.g. 'enrollagreement')
  public errmsg: string = '';// error message (set by validator)
  public haschanges: boolean = false;// indicates when field has changed (set by validator)
};

export class fldDef {
  public id: number = 0;// Identity Key

  // properties common to all modes
  public tableid: string = '';// table id
  public fieldname: string = '';// table record field name
  public dbdatatype: string = '';// moodle datatype
  public datatype: string = '';// how to display: int, bool, date, text, select, popup, buttons
  public colhdr: string = '';// column header text
  public widthval: string = '120';// optional but for now, always treated as px
  public ishtml: boolean = false;// possible html tags embedded and needs to be escaped for moodle (optional, default false)
  public tooltip: string = '';// optional tooltip text

  // list-specific control properties
  public islist: boolean = true;// show in list (optional, default true)
  public issort: boolean = true;// sortable (optional, default true)

  // mode properties specific to the mode.  public addshow: string = '';// how field is displayed: show, hide, readonly
  // add
  public addshow: string = '';// how field is displayed: show, hide, readonly
  public addisnewline: boolean = false;// start on new line?
  public addpopupid: string = '';// popup identifier defined in standard-dialog-add-upd-table.html (e.g. 'enrollagreement')
  public addsellistid: string = '';// sel list for code lookups in table list (optional, default '')
  public addisrequired: boolean = false;// true requires a value (optional, default true)
  // upd
  public updshow: string = '';// how field is displayed: show, hide, readonly
  public updisnewline: boolean = false;// start on new line?
  public updpopupid: string = '';// popup identifier defined in standard-dialog-add-upd-table.html (e.g. 'enrollagreement')
  public updsellistid: string = '';// sel list for code lookups in table list (optional, default '')
  public updisrequired: boolean = false;// true requires a value (optional, default true)

  // everything below is for internal use only and not in the db table

  /*
 "working" set of properties initialized when the dialog is opened and solely for its transitive use.  these are derived from either
 the add/upd mode properties based on whether adding or updating the record. Breaking out these directives simplifes the template logic and
 just requires a quick copy each time the dialog is opened to isolate the properties that are relevant to the mode.
 */
  public show: string = '';// how field is displayed: show, hide, readonly
  public isnewline: boolean = false;// start on new line?
  public popupid: string = '';// popup identifier defined in standard-dialog-add-upd-table.html (e.g. 'enrollagreement')
  public sellistid: string = '';// sel list for code lookups in table list (optional, default '')
  public isrequired: boolean = false;// true requires a value (optional, default true)

  // used by add/upd dialog
  public errmsg: string = '';// error message (set by validator)
  public haschanges: boolean = false;// indicates when field has changed (set by validator)

  // simple flag to condition the field display in the dialog.  this can be different than the show property, for example, in config mode when all fields are shpwn
  public isvisible: boolean = false;// default is hidden
};
export interface fldDefSets {
  [tableid: string]: fldDef[];
}

@Injectable({
  providedIn: 'root'
})
export class GcsTableFieldDefsCacheService {

  tableid = 'flddef';// define our table id
  flddefsets$!: Observable<fldDefSets>;// this defines the field definitions for all tables.  All components use this to dynamically operate on the record
  flddefsets: fldDefSets = {};// points to the cached array in flddefsets$.  This will be available after app init to be used directly by all components

  /*
  +------------------------
  | Initialize the service
  +------------------------*/
  constructor(
    private gcsdatasvc: GcsDataService,
  ) {
    // define the observable to get all table field definitions (this is the master list of all table field definitions used by all components in this solution)
    this.flddefsets$ = this.gcsdatasvc.getlist('table_field_def_get_by_tableid', { tableid: '' }, []).pipe(
      map(flddeflist => {
        // build indexed sets
        let sets = this.flddefsets;// fill this.flddefsets with the indexed sets
        flddeflist.forEach(flddef => {
          // if the tableid is not present, add it
          if (!sets[flddef.tableid]) {
            sets[flddef.tableid] = [];// new set
          }
          sets[flddef.tableid].push(flddef);// add this item to its array
        });
        return sets;// saved as a set of table def arrays, each array keyed on tableid for fast reference.
      }),
      shareReplay(1)// cache the indexexed list into flddefsets$
    );

    // assure the master field definitions array has been initialized
    this.refreshCache();
  }

  refreshCache() {
    this.flddefsets$.subscribe({
      // error
      error: (error: string) => {
        this.gcsdatasvc.showNotification(error, '');
      },
    });
  }

  /*
  +----------------------
  | Other public methods
  +----------------------*/
  // generate displayed columns array for mat-table
  getDisplayedCols(flddefs: fldDef[]) {
    const displayedcolumnlist: string[] = [];

    // Filter to get the subset where islist==true
    flddefs.forEach(a => {
      if (a.islist) {
        displayedcolumnlist.push(a.fieldname);
      }
    });

    return displayedcolumnlist;
  }
  //parseDftList(coldefstr: string, tableid: string) {
  //  let list: fldDef[] = [];

  //  // parse the default def to coldefs array
  //  let coldefs = this.parseMoodleRecStr(coldefstr);

  //  // convert to fldDef array and add to db
  //  coldefs.forEach(coldef => {
  //    let a = new fldDef();
  //    a.id = 0;

  //    a.tableid = tableid;// convert to display value
  //    a.fieldname = coldef.key;
  //    a.dbdatatype = coldef.dbtype;
  //    a.datatype = coldef.type;
  //    a.colhdr = coldef.colhdr;
  //    a.widthval = coldef.widthval;
  //    a.ishtml = coldef.ishtml;
  //    a.tooltip = coldef.tooltip;
  //    a.islist = coldef.islist;
  //    a.issort = coldef.issort;

  //    this.parseColdefForDialogMode(true, coldef);// set work properties for add-mode, then copy them to the add set
  //    a.addshow = coldef.show;
  //    a.addisnewline = coldef.isnewline;
  //    a.addpopupid = coldef.popupid;
  //    a.addsellistid = coldef.sellist;
  //    a.addisrequired = coldef.isrequired;

  //    this.parseColdefForDialogMode(false, coldef);// set work properties for upd-mode, then copy them to the upd set
  //    a.updshow = coldef.show;
  //    a.updisnewline = coldef.isnewline;
  //    a.updpopupid = coldef.popupid;
  //    a.updsellistid = coldef.sellist;
  //    a.updisrequired = coldef.isrequired;

  //    // clear working properties
  //    a.show = '';
  //    a.isnewline = false;
  //    a.popupid = '';
  //    a.sellistid = '';
  //    a.isrequired = false;
  //    a.errmsg = '';
  //    a.haschanges = false;

  //    list.push(a);
  //  });
  //  return list;
  //}

  //// this function is called to parse out either the add or upd definition to set the coldefs used by the dialog template
  //private parseColdefForDialogMode(isAdd: boolean, coldef: columnSchema) {
  //  // init transitive properties of coldefs for add or update mode
  //  coldef.show = 'show';// will contain only one of show, hide, readonly
  //  coldef.isnewline = false;
  //  coldef.popupid = '';
  //  coldef.haschanges = false;
  //  coldef.errmsg = '';

  //  // based on the add/upd mode, modify the coldef for the mode
  //  if (coldef.type === 'buttons') {
  //    coldef.show = 'hide';// always hide buttons
  //  } else {
  //    // use the appropriate property for the mode
  //    let vals = (isAdd ? coldef.add : coldef.upd).split(',');
  //    // process list
  //    for (let i = 0, val; val = vals[i]; i++) {
  //      val = val.trim();
  //      if (val === 'newline') {
  //        coldef.isnewline = true;
  //      } else if (val.indexOf('show=') === 0) {
  //        coldef.show = val.substring(5);
  //      } else if (val.indexOf('popup(') === 0) {
  //        // this designates a supported dialog link
  //        // popupid - identifies the popup to use (see standard-dialog-add-upd-table.html for the proper literal to use)
  //        // (e.g. popup(enrollagreement)

  //        // get contents
  //        coldef.popupid = val.substring(6, val.length - 1);// indicate which popup to use
  //      }
  //    }
  //  }
  //}

  //// OLD SCHEME generate a new columnSchema array from a moodle fields string
  //private parseMoodleRecStr(str: string): columnSchema[] {
  //  let coldefs: columnSchema[] = [];
  //  let lines: string[] = str.split("\n");
  //  lines.forEach(line => {
  //    if (line.trim().length > 0) {
  //      let item = new columnSchema();

  //      // split out comment
  //      let ar = line.split('//');
  //      if (ar.length === 2) {
  //        // field def parse out key & type
  //        let keytypear = ar[0].split(' ');
  //        // key & type
  //        if (keytypear.length >= 2) {
  //          item.key = keytypear[0];
  //          item.dbtype = keytypear[1];
  //          item.type = item.dbtype;// set default but may be changed below

  //          // split out partitioned comment items
  //          let commentar = ar[1].split('|');
  //          // key & type
  //          if (commentar.length > 0) {
  //            item.colhdr = commentar[0];
  //            // process designators...

  //            // Those compiled into columnSchema are:
  //            // nolist, nosort, bool, date, text, width=, sel(), val()

  //            // Those added to upd/add properties to be parsed into flddefsForDialogMode are:
  //            // newline, show=, popup()
  //            for (let i = 1, part: string; part = commentar[i]; i++) {
  //              part = part.trim().toLowerCase();
  //              switch (part) {
  //                case 'nolist': {
  //                  item.islist = false;
  //                  break;
  //                }
  //                case 'nosort': {
  //                  item.issort = false;
  //                  break;
  //                }
  //                case 'bool': {
  //                  if (item.dbtype === 'int') {
  //                    item.type = 'bool';
  //                  }
  //                  break;
  //                }
  //                case 'date': {
  //                  if (item.dbtype === 'int') {
  //                    item.type = 'date';
  //                    item.widthval = '160';// date field dft is wider
  //                  }
  //                  break;
  //                }
  //                case 'text': {
  //                  if (item.dbtype === 'string') {
  //                    item.type = 'text';
  //                  }
  //                  break;
  //                }
  //                case 'html': {
  //                  if (item.dbtype === 'string') {
  //                    item.type = 'text';// handled in ui just like text.
  //                    item.ishtml = true;  // this designator is for fields that contain html tags where moodle needs it escaped(see mdltojs)
  //                  }
  //                  break;
  //                }
  //                case 'newline': {
  //                  item.add = this.gcsdatasvc.commaSep(item.add, part);
  //                  item.upd = this.gcsdatasvc.commaSep(item.upd, part);
  //                  break;
  //                }

  //                default: {// width=,sel(),val(),show=,popup(),upd(),add()
  //                  // width
  //                  if (part.indexOf('tooltip=') === 0) {
  //                    item.tooltip = part.substring(8);
  //                  } else if (part.indexOf('width=') === 0) {// width
  //                    // ends with % or px
  //                    part = part.substring(6);
  //                    if (part.substring(part.length - 1) === '%') {
  //                      item.widthval = part.substring(0, part.length - 1);
  //                    } else if (part.substring(part.length - 2) === 'px') {
  //                      item.widthval = part.substring(0, part.length - 2);
  //                    }
  //                  } else if (part.indexOf('sel(') === 0) {
  //                    // this designates a dynamic select list and takes the form 'sel(sourcetype,source)
  //                    // source type - either 'codeset' or 'tbl'
  //                    // source - either a codeset name or a table designator name (see queueCodeListRef method in the gcs-code-data.service for the proper literal to use)
  //                    // e.g. sel(codeset,term) will populate the select with the term codeset from the codes table
  //                    // e.g. sel(tbl,program) will populate the select with the active programs in the programs table
  //                    // (when field is not required, a blank option is automatically added to the top)
  //                    let ar = part.substring(4, part.length - 1).split(',');// parse csv list within
  //                    if (ar.length === 2) {
  //                      item.type = 'select';
  //                      item.sellist = ar[0].trim() + '_' + ar[1].trim();// used to load the select list from the db
  //                    }
  //                  } else if (part.indexOf('val(') === 0) {
  //                    // this designates a validator list and takes the form 'val(validator,validator...)
  //                    // (only required supported)
  //                    let ar = part.substring(4, part.length - 1).split(',');// parse csv list within
  //                    for (let i = 0, val; val = ar[i]; i++) {
  //                      if (val === 'required') {
  //                        item.isrequired = true;
  //                      }
  //                    }
  //                  } else {
  //                    // either xxx() or xxx= but since either symbol can be present, determine which comes first when both are present
  //                    let eq = part.indexOf('=');// e.g. show=hide
  //                    let par = part.indexOf('(');// e.g. upd=(show=readonly,val(required),popup(enrollagreement))
  //                    if (par > 0 && eq > 0) {
  //                      // first one wins
  //                      if (par < eq) eq = -1; else par = -1;
  //                    }

  //                    // xxx(a,b,c) operation list
  //                    if (par > 0) {
  //                      let k = part.substring(0, par);// upd
  //                      let v = part.substring(par + 1, part.length - 1);// show=readonly,val(required),popup(enrollagreement)

  //                      if (k === 'add') {
  //                        item.add = this.gcsdatasvc.commaSep(item.add, v);// add its instructions to the add property
  //                      } else if (k === 'upd') {
  //                        item.upd = this.gcsdatasvc.commaSep(item.upd, v);// add its instructions to the upd property
  //                      } else {
  //                        // any other operation set like popup() is added to both
  //                        item.add = this.gcsdatasvc.commaSep(item.add, part);
  //                        item.upd = this.gcsdatasvc.commaSep(item.upd, part);
  //                      }
  //                    } else if (eq > 0) {
  //                      // key=val keywords
  //                      // any other is added to both mode lists
  //                      item.add = this.gcsdatasvc.commaSep(item.add, part);
  //                      item.upd = this.gcsdatasvc.commaSep(item.upd, part);
  //                    }
  //                  }
  //                  break;
  //                }
  //              }
  //            }

  //            if (!item.islist) {
  //              item.issort = false;
  //            }
  //          }
  //          item.isnative = true;// this is a native field object
  //          coldefs.push(item);
  //        }
  //      }
  //    }
  //  });
  //  return coldefs;
  //}

  /*
  +----------------------
  | Other public methods
  +----------------------*/
  // general access to table set of field defs
  getFldDefs(tableid: string): fldDef[] {
    return this.flddefsets[tableid] || [];
  }
}
